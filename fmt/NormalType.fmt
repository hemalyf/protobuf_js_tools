{0}
namespace '{1}'
{
	/**
	 * 递归将 “T” 中及其子对象所有属性设置为只读
	 * Make all properties recursive in T readonly
	 */
	type _DeepReadonly<T> = {
		readonly [P in keyof T]: _DeepReadonly<T[P]>;
	};

	//Proto Msg Check
	export type IMsgMap = {
${2}
	};

	//Proto Msg Handler
	const _SCHandlerMap = {
${3}
	};
	export const SCHandlerMap = _SCHandlerMap as _DeepReadonly<typeof _SCHandlerMap>;

	export interface IHandler<T extends keyof IMsgMap, T1 extends keyof IMsgMap[T]> {
		readonly s: T;//		sysid(string)
		readonly c: T1;//		cmdid(string)
		readonly ns: number,//	sysid(number)
		readonly nc: number,//	cmdid(number)
		readonly pt: any,//		protobuf-static class pointer
	};
	const _HandlerMap = {
${4}
	};
	export const HandlerMap = _HandlerMap as _DeepReadonly<typeof _HandlerMap>;

	export function EncodeH<T extends keyof IMsgMap, T1 extends keyof IMsgMap[T]>(_handler: IHandler<T, T1>, proto: IMsgMap[T][T1]) : Uint8Array|undefined {
		try {
			let buffer: protobuf.Writer = _handler.pt.encode(proto);
			return buffer.finish();
		} catch (ex) {
			console.error(`Encode sysid:${_handler.s} cmdid:${_handler.c} failure. error:${ex}`);
		}
	}

	export function DecodeH<T extends keyof IMsgMap, T1 extends keyof IMsgMap[T]>(_handler: IHandler<T, T1>, buffer: Uint8Array) : IMsgMap[T][T1] {
		try {
			return _handler.pt.decode(buffer);
		} catch (ex) {
			console.error(`Decode sysid:${_handler.s} cmdid:${_handler.c} failure. error:${ex}`);
		}
	}


	export function EncodeSC<T extends keyof IMsgMap, T1 extends keyof IMsgMap[T]>(sysid: T, cmdid: T1, proto: IMsgMap[T][T1]) : Uint8Array|undefined {
		const package_handler = SCHandlerMap[sysid];
		if (package_handler == null) {
			console.error(`Encode Proto failure. package type sysid:[${sysid}] cmdid:${cmdid}] not found.`);
			return;
		}
		const cmd_handler = package_handler[<string>cmdid];
		if (cmd_handler == null) {
			console.error(`Encode Proto failure. proto type sysid:[${sysid}] cmdid:${cmdid}] not found.`);
			return;
		}
		try {
			let buffer: protobuf.Writer = cmd_handler.encode(proto);
			return buffer.finish();
		} catch (ex) {
			console.error(`Encode sysid:${sysid} cmdid:${cmdid} failure. error:${ex}`);
		}
	}

	export function DecodeSC<T extends keyof IMsgMap, T1 extends keyof IMsgMap[T]>(sysid: T, cmdid: T1, buffer: Uint8Array) : IMsgMap[T][T1] {
		const package_handler = SCHandlerMap[sysid];
		if (package_handler == null) {
			console.error(`Decode Proto failure. package type sysid:[${sysid}] cmdid:${cmdid}] not found.`);
			return;
		}
		const cmd_handler = package_handler[<string>cmdid];
		if (cmd_handler == null) {
			console.error(`Decode Proto failure. proto type sysid:[${sysid}] cmdid:${cmdid}] not found.`);
			return;
		}
		try {
			return cmd_handler.decode(buffer);
		} catch (ex) {
			console.error(`Decode sysid:${sysid} cmdid:${cmdid} failure. error:${ex}`);
		}
	}
}
